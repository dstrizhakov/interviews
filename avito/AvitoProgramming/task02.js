/*
–£—Å–ª–æ–≤–∏–µ –∑–∞–¥–∞—á–∏
–ù–∞ –ê–≤–∏—Ç–æ —Ä–∞–∑–º–µ—â–µ–Ω–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–æ–≤, –∫–∞–∂–¥—ã–π –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω —á–∏—Å–ª–æ–º. –£ –∫–∞–∂–¥–æ–≥–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –µ—Å—Ç—å –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç—å –≤ —Ç–æ–≤–∞—Ä–µ, —Ç–∞–∫–∂–µ –≤—ã—Ä–∞–∂–µ–Ω–Ω–∞—è —á–∏—Å–ª–æ–º.

–ï—Å–ª–∏ —Ç–æ—á–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞ –Ω–µ—Ç, –ø–æ–∫—É–ø–∞—Ç–µ–ª—å –≤—ã–±–∏—Ä–∞–µ—Ç –±–ª–∏–∂–∞–π—à–∏–π –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é —Ç–æ–≤–∞—Ä, —á—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç –Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—ë–Ω–Ω–æ—Å—Ç—å, —Ä–∞–≤–Ω—É—é —Ä–∞–∑–Ω–∏—Ü–µ –º–µ–∂–¥—É –µ–≥–æ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç—å—é –∏ –∫—É–ø–ª–µ–Ω–Ω—ã–º —Ç–æ–≤–∞—Ä–æ–º.
–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–∂–¥–æ–≥–æ —Ç–æ–≤–∞—Ä–∞ –Ω–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ, –∏ –æ–¥–∏–Ω —Ç–æ–≤–∞—Ä –º–æ–≥—É—Ç –∫—É–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π. –†–∞—Å—Å—á–∏—Ç–∞–π—Ç–µ —Å—É–º–º–∞—Ä–Ω—É—é –Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—ë–Ω–Ω–æ—Å—Ç—å –≤—Å–µ—Ö –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π.

–ù—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–º–µ—Ç –Ω–∞ –≤—Ö–æ–¥ –¥–≤–∞ –º–∞—Å—Å–∏–≤–∞: –º–∞—Å—Å–∏–≤ —Ç–æ–≤–∞—Ä–æ–≤ –∏ –º–∞—Å—Å–∏–≤ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç–µ–π –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π, –≤—ã—á–∏—Å–ª–∏—Ç —Å—É–º–º—É –Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—ë–Ω–Ω–æ—Å—Ç–µ–π –≤—Å–µ—Ö –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π
–∏ –≤–µ—Ä–Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –≤–∏–¥–µ —á–∏—Å–ª–∞.

–ü—Ä–∏–º–µ—Ä
# –ü—Ä–∏–º–µ—Ä
# –≤–≤–æ–¥
goods = [8, 3, 5]
buyerNeeds = [5, 6]
# –≤—ã–≤–æ–¥
res = 1 # –ø–µ—Ä–≤—ã–π –ø–æ–∫—É–ø–∞—Ç–µ–ª—å –ø–æ–∫—É–ø–∞–µ—Ç —Ç–æ–≤–∞—Ä 5 –∏ –µ–≥–æ –Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—ë–Ω–Ω–æ—Å—Ç—å = 0, –≤—Ç–æ—Ä–æ–π —Ç–∞–∫–∂–µ –ø–æ–∫—É–ø–∞–µ—Ç —Ç–æ–≤–∞—Ä 5 –∏ –µ–≥–æ –Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—ë–Ω–Ω–æ—Å—Ç—å = 6-5 = 1
*/

function calculateDissatisfaction(goods, buyerNeeds) {
    goods.sort((a, b) => a - b);
    let totalDissatisfaction = 0;
    for (let need of buyerNeeds) {
        let pos = binarySearch(goods, need);
        let bestMatch = Infinity;
        if (pos < goods.length) {
            bestMatch = Math.abs(goods[pos] - need);
        }
        if (pos > 0) {
            bestMatch = Math.min(bestMatch, Math.abs(goods[pos - 1] - need));
        }

        totalDissatisfaction += bestMatch;
    }

    return totalDissatisfaction;
}

// –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ —Ç–æ–≤–∞—Ä–∞
function binarySearch(arr, target) {
    let left = 0, right = arr.length;
    while (left < right) {
        let mid = Math.floor((left + right) / 2);
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}





// // –ü—Ä–∏–º–µ—Ä
let goods = [8, 3, 5];
let buyerNeeds = [5, 6];
// console.log(calculateDissatisfaction(goods, buyerNeeds));  // –í—ã–≤–æ–¥: 1

/*
–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –º–∞—Å—Å–∏–≤–∞ —Ç–æ–≤–∞—Ä–æ–≤ –∑–∞–Ω–∏–º–∞–µ—Ç ùëÇ(mlogm), –≥–¥–µ m ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–æ–≤.
–î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –±–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –∑–∞ ùëÇ(logùëö), –∏ –¥–ª—è –≤—Å–µ—Ö –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –±—É–¥–µ—Ç O(nlogm)
–ò—Ç–æ–≥: O(mlogm+nlogm), —á—Ç–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –¥–ª—è –±–æ–ª—å—à–∏—Ö –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.
 */

function calculateDissatisfaction1(goods, buyerNeeds) {
    let totalDissatisfaction = 0;
    for (let need of buyerNeeds) {
        let bestMatch = Infinity;
        for (let good of goods) {
            bestMatch = Math.min(bestMatch, Math.abs(good - need));
        }
        totalDissatisfaction += bestMatch;
    }
    return totalDissatisfaction;
}

// console.log(calculateDissatisfaction1(goods, buyerNeeds));  // –í—ã–≤–æ–¥: 1

/* –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã:
    –î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –º—ã –ø—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º —Ç–æ–≤–∞—Ä–∞–º, —Ç–æ –µ—Å—Ç—å –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ–ø–µ—Ä–∞—Ü–∏—è O(m).
    –í —Å—É–º–º–µ, –µ—Å–ª–∏ —É –Ω–∞—Å ùëõ –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π m —Ç–æ–≤–∞—Ä–æ–≤, —Å–ª–æ–∂–Ω–æ—Å—Ç—å –±—É–¥–µ—Ç O(n * m).

–í —ç—Ç–æ–º —Ä–µ—à–µ–Ω–∏–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å –±—É–¥–µ—Ç –ª–∏–Ω–µ–π–Ω–æ–π –ø–æ —á–∏—Å–ª—É –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π –∏ —Ç–æ–≤–∞—Ä–æ–≤, —á—Ç–æ —Ö—É–∂–µ, —á–µ–º —Ä–µ—à–µ–Ω–∏–µ —Å –±–∏–Ω–∞—Ä–Ω—ã–º –ø–æ–∏—Å–∫–æ–º,
–Ω–æ –æ–Ω–æ –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç–æ–µ –∏ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –∏ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞.
–ï—Å–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–æ–≤ –∏ –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π –±—É–¥–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –Ω–µ–±–æ–ª—å—à–∏–º, —ç—Ç–æ—Ç –ø–æ–¥—Ö–æ–¥ –≤–ø–æ–ª–Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç.
–û–¥–Ω–∞–∫–æ –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤ –¥–∞–Ω–Ω—ã—Ö –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫, –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–º —Ä–µ—à–µ–Ω–∏–∏.
 */


function simpleCalc(goods, needs) {
    let total = 0;
    needs.forEach(need => {
        let best = Infinity;
        goods.forEach(good => {
            best = Math.min(best, Math.abs(good - need))
        })
        total += best
    })
    return total;
}

// console.log(simpleCalc(goods, buyerNeeds));

function diffCalc(goods, needs) {
    goods.sort();
    return needs.reduce((total, need) => {
        const pos = binSear(goods, need);
        const rightResult = pos < goods.length ? Math.abs(goods[pos] - need) : Infinity;
        const leftResult = pos > 0 ? Math.abs(goods[pos - 1] - need) : Infinity;
        return total + Math.min(rightResult, leftResult);
    }, 0)
}

function binSear(arr, target) {
    let left = 0, right = arr.length - 1;
    while (left < right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid
        }
        console.log(arr, arr[left], arr[right])
    }
    return left;
}

// console.log(diffCalc(goods, buyerNeeds));

function binSearch (goods, need) {
    let left = 0, right = goods.length - 1;
    while(left < right) {
        let mid = Math.floor((left + right) / 2);
        const current = goods[mid];
        if (current < need) {
            left = mid + 1
        } else {
            right = mid;
        }
        console.log(goods, goods[left], goods[right])
    }
    return left
}


function getDissatisfaction (goods, needs) {
    goods.sort((a, b) => a - b);
    let total = 0;
    for (let need of needs) {
        let pos = binSearch(goods, need);
        let nearest = Infinity;
        if (pos < goods.length) {
            nearest = Math.abs(goods[pos] - need)
        }
        if (pos > 0) {
            nearest = Math.min(nearest, Math.abs(goods[pos - 1] - need))
        }
        total += nearest;
    }
    return total;
}

console.log(getDissatisfaction(goods, buyerNeeds));